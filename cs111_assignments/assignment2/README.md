# Lab Assignment 2 (Bonus Assignment)

For this lab assignment, you will correct and improve your solutions to Lab Assignment 1.  All points earned from this assignment will be considered bonus points.  You will test your API and fix any bugs.  If you lost any points on the first assignment, you will be able to recouperate the lost points by fixing the erroneous methods (you will receive your Assignment 1 grade by Wednesday).  Therefore, you have the opportunity to earn perfect score on Asssignment 1.  In addition to fixing any bugs, you will be to earn additional bonus points by improving the style of your code.  This involves modifying your code so that it adheres with the [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html). You should also change the names of your variables so that they are more descriptive.

In this Lab Assignment you will learn to:
1. Use the debugger
2. Create and run Unit tests
3. Write cleaner code

## Fork the repository
If you have not made a [github](www.github.com) account, do so at this time. Once you've created an account, go to my  [cs111_assignments repository](https://github.com/vonclites/cs111_assignments). Click on the "Fork" button at the top right of the website. You will be automatically sent to your own repository, which now holds a copy of the cs111_assignments repository. Next, select "Settings" tab (slightly below the Watch / Star / Fork buttons). Scroll to the bottom and make the repository private.  On the left portion of the Settings page, switch to the Collaborator & teams tab. Add me, "vonclites", as a collaborator. If you have a team mate, you can add him or her as a collaborator too.

## Setup Eclipse
First, replace the incomplete ERDataAnalyzer.java and ERDataReader.java files in assignment2/src/er\_data with the versions you submitted.  If you do not have the code you submitted, I can provide it to you. Finally, recreate the project in Eclipse by creating a new project in the same location as the cs111_assignments/assignment2 directory.

## Answers to Assignment 1

In order to check your API, here is the correct output for each ERDataAnalyzer method:

```java
// patientsPerDayOfWeek
int[] answer = {3118, 2746, 2921, 2676};

// patientsPerDayPerWeek
int[][] answer = {{476, 537, 421, 362, 461, 431, 430},
		 {371, 362, 461, 349, 395, 486, 322},
		 {431, 531, 395, 383, 313, 434, 434},
		 {476, 461, 454, 265, 272, 348, 400}};

// averagePatientsPerWeek
int[] answer = {445.42857142857, 392.2857142857, 417.2857142857, 382.2857142857};

// averagePatientsPerDayAcrossWeeks
int[] answer = {438.5, 472.75, 432.75, 339.75, 360.25, 424.75, 396.5};

// busiestDayPerWeek
int[] answer = {1, 5, 1, 0};

//leastBusyDayPerWeek
int[] answer = {3, 6, 4, 3};
```

## Unit tests
Notice that in Assignment 2 we do not have the main program we were previously using to run our code. That's fine, we don't need it.  Instead, we'll use Java's unit testing library called JUnit to validate our code.

First let's test our readData() method. To do this, we will read in data from a test file whose values can be easily verified. The generateTestData() function is reproduce the values exactly as they appear in the data file. Then, we can compare the generated data to that which was read in from the file.

```java
// imports

public class ERDataReaderTest {
	private static final int DEFAULT_WEEKS = 4;
	private static final int DEFAULT_DAYS = 7;
	private static final int DEFAULT_HOURS = 24;

	// Data file containing the same values generated by generateTestData()
	private static final String TEST_DATA_FILE = "data/test_data.txt"; 
	
	private static int[][][] generateTestData() {
		int[][][] data = new int[DEFAULT_WEEKS][DEFAULT_DAYS][DEFAULT_HOURS];
		
		for (int week = 0; week < DEFAULT_WEEKS; week++) {
			for (int day = 0; day < DEFAULT_DAYS; day++) {
				for (int hour = 0; hour < DEFAULT_HOURS; hour++) {
					data[week][day][hour] = week + day + hour;
				}
			}
		}
		return data;
	}
	
	@Test
	public void testReadData() 
			throws FileNotFoundException, NoSuchElementException, IllegalStateException, IOException, Exception {
		
		int[][][] expecteds = generateTestData();
		int[][][] actuals = ERDataReader.readData(TEST_DATA_FILE);
		
		assertArrayEquals(expecteds, actuals);
	}

}
```
If we run this test class, we JUnit will tell us whether or not our readData() method has returned the expected output. If the JUnit imports, such as org.junit.Test, in the ERDataReaderTest class have errors like "The import org.junit cannot be resolved" then allow Eclipse to fix the issue by mousing over the error and selecting "Fix project setup". Eclipse will then add the JUnit library to the build path. 

If we have verified we are reading data correctly, we can start to test our ERDataAnalyzer. Here is an example test class which tests one method of the ERDataAnalyzer class:

```java
// imports

public class ERDataAnalyzerTest {
	private static final String DATA_FILE = "data/data1.txt";

	@Test
	public void testPatientsPerWeek()
			throws FileNotFoundException, NoSuchElementException, IllegalStateException {
	// We are assuming our ERDataReader works...
		int[][][] testData = ERDataReader.readData(DATA_FILE);
		int[] expecteds = {3118, 2746, 2921, 2676};
		int[] actuals = ERDataAnalyzer.patientsPerWeek(testData);
		assertArrayEquals(expecteds, actuals);
	}
}
```

Now, write unit tests for the remaining ERDataAnalyzer methods.

## Alternative testing
Perhaps we do not want to wait until we have a functioning readData method before testing ERDataAnalyzer. In this case we have a few options.
1. Make generateTestData() from our ERDataReaderTest class public. We could use this data since we know what the values are that get generated. However, if we use this approach, we still don't necessarily know what the correct output should be of the ERDataAnalyzer functions - we would only know what the input data is.

2. Fabricate simpler test data.  Instead of calculating statistics on a 4 x 7 x 24 array, we could create data for a 2 x 2 x 2 array, for example.  It is much easier to determine the expected output from a smaller array.  However, if we take this approach, then we must alter our ERDataAnalyzer methods to operate on 3d arrays of _any_ size (which is something you should probably do anyway).

## Debugging
If one of the unit tests fails, we can use Eclipse's built in Java debugger to find the source of the error.  Using the debugger is far superior to using print statements or mentally thinking through the code.

Place a breakpoint in the method which is causing the failure. You can place a breakpoint by double left-clicking in the margin to the left of the code. This is the same column where the line numbers appear (if you have line numbers set to be visible).

Once you have set a breakpoint, you can re-run the test in debug mode by clicking on the bug-looking button at the top of the window, near the Run button. Eclipse may warn you if your file contains errors when you try to run the debugger.  Continue anyway, and confirm that you want to change your perspective to the Debug perspective.

Your program will now run up to the point of the breakpoint and then pause its execution. At this point you can "Step Over" (hotkey is F6) to begin executing one line of code at a time, or you can "Step Into" (F5) to enter into any methods at the current line in order to see what is going on "underneath the hood."

## Clean coding
In this assignment, we will not only validate the correctness of our code, but also improve its organization and readability. Particularly, we will focus on

1. Adhering to the [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)
  * Pay special attention the following style guidelines:
    * [Whitespace](https://google.github.io/styleguide/javaguide.html#s4.6-whitespace)
    * [Naming Conventions](https://google.github.io/styleguide/javaguide.html#s5.2-specific-identifier-names)
    * [Column Limits](https://google.github.io/styleguide/javaguide.html#s4.4-column-limit)
    * [Indentation](https://google.github.io/styleguide/javaguide.html#s4.2-block-indentation) 
2. Choosing good variable names
3. Functional decomposition

